---
title: "Fst Genoprob Features"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Create fst_genoprob for qtl2 data}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 7, fig.height = 5)
```

The motivation for the
[qtl2feather](https://github.com/byandell/qtl2feather) package was to
reduce memory usage by [R/qtl2](http://kbroman.org/qtl2). Matt Vincent
reported that memory is his greatest obstacle when running QTL
browsers, because he cannot add more [R
plumber](https://www.rplumber.io/) workers. Also, if you have a cheap
Windows laptop you cannot even open many DO `.RData` projects simply
because the haplotype probability object is too big.

The solution would be to store data in some database and load just a
slice you need at a time. We experimented with `SQLite` but it was too
slow (though it could possibly be optimised, perhaps via adding
relevant indexes). Then we tried
[feather](https://github.com/wesm/feather) and it worked fine; we
built the idea into the package
[qtl2feather](https://github.com/byandell/qtl2feather). Some aspects
of R/qtl2 needed to be modified to work with it.

A weakness of [feather](https://github.com/wesm/feather) is that it is
not under active development (just a couple of commits during the last
year). And so the present package,
[qtl2fst](https://github.com/kbroman/qtl2fst), uses the same approach as
[qtl2feather](https://github.com/byandell/qtl2feather) but relying on
the [fst package](http://www.fstpackage.org). Another advantage of fst
over feather, is that fst includes an option to write a compressed
database; slower to read and write but uses less disk space.

```{r, load_packages}
library(qtl2)
library(qtl2fst)
```

```{r, load_DOex_data}
DOex <- read_cross2("https://raw.githubusercontent.com/rqtl/qtl2data/master/DOex/DOex.zip")
```

Calculate genotype probabilities and convert to allele probabilities.

```{r, calc_alleleprob}
pr <- calc_genoprob(DOex, error_prob=0.002)
apr <- genoprob_to_alleleprob(pr)
```

Write fst database of the genotype probabilities to a temporary
directory; similarly for the allele probabilities.

```{r write_fst_db}
tmpdir <- tempdir()
fpr <- fst_genoprob(pr, "pr", tmpdir)
fapr <- fst_genoprob(apr, "apr", tmpdir)
```

List the files in the directory

```{r list_files}
list.files(tmpdir)
```

Methods `names()` and `length()` both work properly.

```{r, names_length_fpr}
names(fpr)
length(fpr)
```

Methods `dim()` and `dimnames()` give dimensions across the chromosomes.
Notice that `fpr` has different genotypes for the `X` chromosome.

```{r dim_fpr}
dim(fpr)
str(dimnames(fpr))
```


### Selecting one chromosome

Selecting a chromosome causes reading from fst database and creation of an array.

```{r, read_chromosome}
dim(fapr[["X"]])
```

Here's an alternate form, using `$`.

```{r}
dim(fapr$X)
```

### Subsetting by ind, chr, mar

Subsetting using `subset(object,ind,chr,mar)` or `[ind,chr,mar]` only adjusts the vector of
individuals, chromosomes and markers, but does not alter the fst database.

```{r subset_fapr}
dim(subset(fapr, ind=1:20, chr=c("2","3")))
```

You can also use `[]` to subset.

```{r subset_brackets}
dim(fapr[1:20, c("2","3")][["3"]])
```

```{r other_subsetting}
f2 <- fapr[,"2"]
f23 <- fapr[,c("2","3")]
fx <- fapr[,"X"]
```

There is a third dimension for markers. However, be careful that if you select a subset of markers that excludes one or more chromosomes, those will be dropped.

```{r select_markers}
dim(subset(fapr, mar=1:30))
dim(fapr[ , , dimnames(fapr)$mar$X[1:20]])
```

### Binding by columns or rows.

Binding by columns (chromosomes) or rows (individuals) may cause creation of a new fst database if input objects arose from different fst databases. However, if objects are subsets of the same `fst_genoprob` object, then it reuses the one fst database. Further, if objects have the same directory and file basename for their fst databases, they will be combined without creation of any new fst databases.

See `example(cbind.fst_genoprob)` and `example(rbind.fst_genoprob)` with objects having distinct fst databases.

Here's column bind (chromosomes).

```{r cbind_fapr}
newf23 <- cbind(f2,f23)
```

And here's row bind (individuals)..

```{r rbind_fapr}
f23a <- fapr[1:20, c("2","3")]
f23b <- fapr[40:79, c("2","3")]
f23 <- rbind(f23a, f23b)
```

Subset on markers. This way only extracts the selected `markers` from
the fst database before creating the array.

```{r subset_markers}
markers <- dimnames(fapr$X)[[3]][1:10]
dim(fapr[,,markers]$X)
```

This way extracts all markers on `X`, creates the array, then subsets on selected `markers`.

```{r extract_markers_chr_X}
markers <- dimnames(fapr$X)[[3]][1:10]
dim(fapr$X[,,markers])
```

Two `fst_genoprob` objects using the same database. Combine using `cbind`. Notice that the order of chromosomes is reversed by joining `fapr2` to `fapr3`. Be sure to not overwrite existing fst databases!

```{r cbind_two_subsets}
fapr2 <- fst_genoprob(subset(apr, chr="2"), "aprx", tmpdir)
fapr3 <- fst_genoprob(subset(apr, chr="3"), "aprx", tmpdir)
fapr32 <- cbind(fapr3,fapr2)
dim(fapr32)
list.files(tmpdir)
```

### Looking under the hood at `fst_genoprob` object

Here are the names of elements in a `fst_genoprob` object:

```{r names_fapr}
names(unclass(fapr))
```

```{r fapr_fst_path}
unclass(fapr)$fst
```

```{r ind_chr_mar_pieces}
sapply(unclass(fapr)[c("ind","chr","mar")], length)
```

A `fst_genoprob` object has all the original information. Thus, it is possible to restore the original object from a `subset` (but not necessarily from a `cbind` or `rbind`). Here is an example.

```{r restore_from_subset}
fapr23 <- subset(fapr, chr=c("2","3"))
dim(fapr23)
dim(fst_genoprob_restore(fapr23))
```

## Time trial simulation

Compare times to create `pr` once and to Read `fpr` 100 times.

```{r calc_genoprob_time}
system.time(pr <- calc_genoprob(DOex, error_prob=0.002))
```

```{r create_db_time}
system.time(fpr <- fst_genoprob(pr, "pr", tmpdir, verbose = FALSE))
```

```{r read_db_time}
tmpfile <- tempfile()
saveRDS(pr, file = tmpfile)
size_pr <- file.size(tmpfile) * 1e-6
unlink(tmpfile)
```

```{r function_to_get_files}
files <- function(fst_genoprob)
{
    path <- unclass(fst_genoprob)$fst
    file.path(dirname(path), list.files(dirname(path), paste0("^", basename(path))))
}
fst_size <- function(fst_genoprob)
{
    sum(file.size(files(fst_genoprob))) / 1024^2
}

```

The `pr` object is `r format(object.size(pr), units = "Mb")`
in `R` or `r round(size_pr, 1)` Mb if saved as RDS file, while the `fpr` object is
`r format(object.size(fpr), units = "Mb")` in R with additional
`r round(fst_size(fpr), 1)` Mb for saved fst databases.

#### Time to extract chromosome information.

Extract chromosome `"2"` 100 times.

```{r extract_chr_time}
system.time({
  for(i in seq(100))
    tmp <- fpr[["2"]]
})
```

Extract first 50 markers from chromosome `"2"` 100 times.
```{r extract_markers_time}
markers <- dimnames(fpr)$mar[["2"]][1:50]
system.time({
  for(i in seq(100))
    tmp <- fpr[["2"]]
})
```
